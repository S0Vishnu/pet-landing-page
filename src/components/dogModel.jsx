/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { Suspense, useEffect, useRef, useState } from "react";
import {
  useGLTF,
  useAnimations,
  Environment,
  OrthographicCamera,
  OrbitControls,
  PerformanceMonitor,
  SoftShadows,
  Stage,
} from "@react-three/drei";
import {
  MeshStandardMaterial,
  DoubleSide,
  LoopOnce,
  Box3,
  Vector3,
  MeshToonMaterial,
} from "three";
import { Canvas, useThree } from "@react-three/fiber";
import gsap from "gsap";

function Model({ animation, setAction, ...props }) {
  console.log("animation: ", animation);
  const group = useRef();
  const { nodes, materials, animations } = useGLTF("/models/dog.gltf");
  const { actions } = useAnimations(animations, group);

  const [loading, setLoading] = useState(false);

  const standardMaterial = new MeshStandardMaterial({
    roughness: 0.8,
    metalness: 0.1,
    map: materials.Material_0.map, // Copy the color if available
    side: DoubleSide, // Ensure the material is visible from both sides
  });

  const toonMaterial = new MeshToonMaterial({
    map: materials.Material_0.map, // You can keep the texture from the original material
    color: 0xffffff, // Base color, if no texture is provided
    lightMap: materials.Material_0.lightMap, // Optional light map for better shading
    specular: 0x555555, // Specular highlight
    shininess: 10, // Smoothness of the material
    side: DoubleSide, // Ensure material is visible from both sides
    flatShading: true, // Makes the shading flat (toon-like)
  });

  useEffect(() => {
    const timer = setTimeout(() => {
      if (group.current) {
        console.log("loading...");

        // Animating the scale and position
        gsap.to(group.current.scale, {
          x: 1,
          y: 1,
          z: 1,
          duration: 0.2, // Animation duration in seconds
          ease: "power2.out", // Easing function for smooth transition
        });

        gsap.to(group.current.position, {
          y: -0.45,
          duration: 0.2, // Animation duration
          ease: "power2.out",
          start: { y: 2 },
        });

        setLoading(true);
        console.log("offset");
      }
    }, 1000);
    return () => clearTimeout(timer);
  }, [loading]);

  useEffect(() => {
    const action = actions[animation];
    if (action) {
      const mixer = action.getMixer(); // Get the mixer associated with the action

      action.reset().fadeIn(0.24).play();

      console.log("animation: ", animation);
      if (animation !== "standing" && animation !== "sitting") {
        action.clampWhenFinished = true; // Ensure the animation stops at the last frame
        action.loop = LoopOnce; // Play the animation only once
      } else {
        action.clampWhenFinished = false; // Ensure the animation does not clamp
        action.loop = -1; // Play the animation infinitely
      }

      // Event listener for 'finished' using the mixer
      const onFinished = (event) => {
        if (event.action === action) {
          if (animation !== "sitting") {
            console.log("finished");
            setAction("sitting");
          }
        }
      };

      mixer.addEventListener("finished", onFinished);
      return () => {
        action.fadeOut(0.24);
        mixer.removeEventListener("finished", onFinished); // Cleanup listener
      };
    }
  }, [animation]);

  //   useEffect(() => {
  //    actions[animation]?.reset().fadeIn(0.4).play();
  //    return () => actions?.[animation]?.fadeOut(0.4);
  //   }, [animation]);

  return (
    <Suspense fallback={console.log("Loading Completed....")}>
      <group ref={group} {...props} dispose={null} scale={[0, 0, 0]}>
        <group name="Scene">
          <group name="RootNode0" scale={0.01}>
            <group name="geo1" />
            <group name="skeletal3">
              <skinnedMesh
                name="shiba_inu2"
                geometry={nodes.shiba_inu2.geometry}
                material={toonMaterial}
                skeleton={nodes.shiba_inu2.skeleton}
                castShadow
                receiveShadow
              />
              <primitive object={nodes.root4} castShadow receiveShadow />
            </group>
          </group>
        </group>
      </group>
    </Suspense>
  );
}

useGLTF.preload("/models/dog.gltf");

function ShadowCatcher() {
  const planeRef = useRef();
  return (
    <mesh
      ref={planeRef}
      receiveShadow // Enable shadow reception
      rotation={[-Math.PI / 2, 0, 0]} // Rotate plane to be horizontal
      position={[0, -0.45, 0]} // Position the plane slightly below the model
    >
      <planeGeometry args={[10, 10]} /> {/* Adjust size as needed */}
      {/* <meshBasicMaterial color={"orange"}/> */}
      <shadowMaterial opacity={0.4} />
      {/* Adjust shadow intensity */}
    </mesh>
  );
}

export default function DogModel() {
  const [action, setAction] = useState("sitting");
  const shadowCameraRef = useRef();
  return (
    <div className="dog-model-container">
      <div className="background"></div>
      <div className="canvas-container">
        <Canvas
          className="canvas"
          camera={{ position: [2, 0.78, 2.16], fov: 40 }}
          shadows
        >
          <PerformanceMonitor onDecline={() => set(true)} />
          <SoftShadows samples={16} />
          <Environment preset="city" />
          <directionalLight
            castShadow
            position={[5, 10, 5]}
            intensity={1}
            shadow-mapSize={[1024, 1024]} // Higher resolution for better shadow quality
          />
          <OrbitControls
            minPolarAngle={Math.PI / 3} // Prevent rotating below the horizontal plane
            maxPolarAngle={Math.PI / 2} // Prevent rotating above 90 degrees
            minAzimuthAngle={-Math.PI / 3}
            maxAzimuthAngle={Math.PI / 3}
            enableZoom={false} // Disable zoom functionality
          />
          <Stage
            intensity={0.5}
            environment="city"
            shadows={{ type: "accumulative", bias: -0.001, intensity: Math.PI }}
            adjustCamera={false}
          >
            <Model animation={action} setAction={setAction} />
          </Stage>
          <ShadowCatcher />
        </Canvas>
      </div>
      <div className="switch-action-container">
        <div
          className="switch-action"
          onClick={() => {
            setAction("play_dead");
            console.log("clicked");
          }}
        >
          Play Dead
        </div>
        <div
          className="switch-action"
          onClick={() => {
            setAction("rollover");
          }}
        >
          Rollover
        </div>
        <div
          className="switch-action"
          onClick={() => {
            setAction("shake");
          }}
        >
          Shake
        </div>
        <div
          className="switch-action"
          onClick={() => {
            setAction("standing");
          }}
        >
          Standing
        </div>
      </div>
    </div>
  );
}
// play_dead, rollover, shake, sitting, standing
